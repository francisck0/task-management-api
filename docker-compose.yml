# ============================================================================
# DOCKER COMPOSE PARA TASK MANAGEMENT API
# ============================================================================
#
# Este archivo orquesta múltiples servicios:
# 1. app: Aplicación Spring Boot (Task Management API)
# 2. postgres: Base de datos PostgreSQL 18
# 3. pgadmin: Herramienta de administración de PostgreSQL (opcional)
#
# IMPORTANTE: Este archivo está configurado para DESARROLLO.
# En producción, usar configuración hardened con secrets, SSL/TLS, etc.
#
# ============================================================================

services:
  # ============================================================================
  # SERVICIO: APLICACIÓN SPRING BOOT
  # ============================================================================
  app:
    # Construir imagen desde Dockerfile en el directorio actual
    build:
      context: .              # Directorio donde está el Dockerfile
      dockerfile: Dockerfile  # Nombre del Dockerfile
      # (Opcional) Argumentos de build
      # args:
      #   - BUILD_VERSION=1.0.0

    image: task-management-api:latest  # Nombre de la imagen resultante
    container_name: taskmanager-app    # Nombre del contenedor
    restart: unless-stopped            # Política de reinicio

    # Variables de entorno para la aplicación
    environment:
      # Perfil de Spring Boot (dev, test, prod)
      SPRING_PROFILES_ACTIVE: ${SPRING_PROFILE:-dev}

      # Configuración de base de datos
      # Usa el nombre del servicio 'postgres' como hostname (Docker DNS interno)
      SPRING_DATASOURCE_URL: jdbc:postgresql://postgres:5432/${POSTGRES_DB:-taskmanagement_db}
      SPRING_DATASOURCE_USERNAME: ${POSTGRES_USER:-postgres}
      SPRING_DATASOURCE_PASSWORD: ${POSTGRES_PASSWORD:-postgres}

      # Pool de conexiones HikariCP
      SPRING_DATASOURCE_HIKARI_MAXIMUM_POOL_SIZE: 10
      SPRING_DATASOURCE_HIKARI_MINIMUM_IDLE: 5
      SPRING_DATASOURCE_HIKARI_CONNECTION_TIMEOUT: 20000

      # JPA/Hibernate
      SPRING_JPA_HIBERNATE_DDL_AUTO: validate  # En prod: validate (no modificar schema)
      SPRING_JPA_SHOW_SQL: false               # No mostrar SQL en logs (usa Logback)

      # JWT Configuration
      JWT_SECRET: ${JWT_SECRET:-your-secret-key-change-in-production-min-256-bits}
      JWT_EXPIRATION: ${JWT_EXPIRATION:-86400000}  # 24 horas en milisegundos

      # Server
      SERVER_PORT: 8080

      # Logging
      LOGGING_LEVEL_ROOT: INFO
      LOGGING_LEVEL_COM_TASKMANAGEMENT_API: ${LOG_LEVEL:-DEBUG}

      # Actuator
      MANAGEMENT_ENDPOINTS_WEB_EXPOSURE_INCLUDE: health,info,metrics,prometheus

      # Zona horaria
      TZ: America/Mexico_City

      # JAVA_OPTS (ya definidos en Dockerfile, se pueden sobrescribir aquí)
      # JAVA_OPTS: "-Xmx512m -Xms256m"

    ports:
      # Puerto expuesto: host:contenedor
      - "${APP_PORT:-8080}:8080"

    # Volúmenes (opcional, para desarrollo hot-reload)
    # volumes:
    #   - ./logs:/app/logs  # Persistir logs fuera del contenedor

    # Limitar recursos del contenedor
    deploy:
      resources:
        limits:
          cpus: '1.0'       # Máximo 1 CPU
          memory: 1G        # Máximo 1GB de RAM
        reservations:
          cpus: '0.25'      # Mínimo 0.25 CPU reservado
          memory: 256M      # Mínimo 256MB reservado

    # Dependencias: La app necesita que PostgreSQL esté saludable
    depends_on:
      postgres:
        condition: service_healthy  # Espera a que postgres pase el healthcheck

    # Red
    networks:
      - taskmanager-network

    # Health check de la aplicación
    # Verifica el endpoint de Actuator
    healthcheck:
      test: ["CMD", "curl", "-f", "http://localhost:8080/api/v1/actuator/health"]
      interval: 30s        # Verifica cada 30 segundos
      timeout: 5s          # Timeout de 5 segundos
      retries: 3           # 3 intentos antes de marcar como unhealthy
      start_period: 60s    # Espera 60 segundos antes de empezar healthchecks

  # ============================================================================
  # SERVICIO: POSTGRESQL 18
  # ============================================================================
  # Servicio de PostgreSQL 18
  # PostgreSQL 18 incluye mejoras en performance, particionado y seguridad
  postgres:
    image: postgres:18-alpine
    container_name: taskmanager-postgres
    restart: unless-stopped  # Reinicia automáticamente excepto si se detiene manualmente

    environment:
      # Configuración de la base de datos
      POSTGRES_DB: ${POSTGRES_DB:-taskmanagement_db}
      POSTGRES_USER: ${POSTGRES_USER:-postgres}
      POSTGRES_PASSWORD: ${POSTGRES_PASSWORD:-postgres}

      # IMPORTANTE: En producción, usar contraseñas fuertes y cambiar el usuario por defecto
      # Considerar usar secrets de Docker en lugar de variables de entorno

      # Configuraciones de performance y seguridad
      # POSTGRES_INITDB_ARGS: Argumentos para inicializar la base de datos
      # --encoding=UTF8: Codificación UTF-8 para soporte internacional completo
      # --locale=es_ES.UTF-8: Locale español (cambiar según necesidad)
      # --data-checksums: Habilita checksums para detectar corrupción de datos
      POSTGRES_INITDB_ARGS: "--encoding=UTF8 --locale=C --data-checksums"

      # Zona horaria (ajustar según ubicación)
      TZ: America/Mexico_City

    ports:
      # Puerto expuesto: host:contenedor
      # En producción, considerar NO exponer el puerto y usar red interna
      - "${POSTGRES_PORT:-5432}:5432"

    volumes:
      # Persistencia de datos
      # Los datos se mantienen incluso si el contenedor se elimina
      - postgres_data:/var/lib/postgresql/data

      # (Opcional) Scripts de inicialización
      # Cualquier archivo .sql o .sh en ./init-scripts se ejecutará al crear la BD
      # - ./init-scripts:/docker-entrypoint-initdb.d

      # (Opcional) Configuración personalizada de PostgreSQL
      # - ./postgresql.conf:/etc/postgresql/postgresql.conf

    # Configuraciones de performance del contenedor
    # Limitar recursos para evitar que PostgreSQL consuma todos los recursos del host
    deploy:
      resources:
        limits:
          cpus: '2.0'      # Máximo 2 CPUs
          memory: 2G       # Máximo 2GB de RAM
        reservations:
          cpus: '0.5'      # Mínimo 0.5 CPU reservado
          memory: 512M     # Mínimo 512MB reservado

    # Configuración adicional mediante command
    # Optimizaciones de PostgreSQL para desarrollo
    command:
      - "postgres"
      # shared_buffers: Memoria para cachear datos (25% de RAM disponible)
      - "-c"
      - "shared_buffers=512MB"
      # effective_cache_size: Estimación de memoria disponible para cache (50-75% de RAM)
      - "-c"
      - "effective_cache_size=1536MB"
      # work_mem: Memoria para operaciones de ordenamiento (RAM / max_connections / 4)
      - "-c"
      - "work_mem=16MB"
      # maintenance_work_mem: Memoria para VACUUM, CREATE INDEX, etc.
      - "-c"
      - "maintenance_work_mem=128MB"
      # max_connections: Número máximo de conexiones simultáneas
      - "-c"
      - "max_connections=100"
      # checkpoint_completion_target: Distribuye escrituras del checkpoint
      - "-c"
      - "checkpoint_completion_target=0.9"
      # wal_buffers: Buffers para Write-Ahead Logging
      - "-c"
      - "wal_buffers=16MB"
      # random_page_cost: Ajuste para SSD (1.1) o HDD (4.0)
      - "-c"
      - "random_page_cost=1.1"
      # effective_io_concurrency: Mayor en SSD (200), menor en HDD (2)
      - "-c"
      - "effective_io_concurrency=200"
      # log_statement: Registra todas las sentencias SQL (útil en desarrollo)
      - "-c"
      - "log_statement=all"
      # log_duration: Registra la duración de cada sentencia
      - "-c"
      - "log_duration=on"
      # log_min_duration_statement: Solo registra queries lentas (en ms, -1 = deshabilitado)
      - "-c"
      - "log_min_duration_statement=1000"

    networks:
      - taskmanager-network

    healthcheck:
      # Verificación de salud del contenedor
      # pg_isready verifica que PostgreSQL esté aceptando conexiones
      test: ["CMD-SHELL", "pg_isready -U ${POSTGRES_USER:-postgres} -d ${POSTGRES_DB:-taskmanagement_db}"]
      interval: 10s        # Verifica cada 10 segundos
      timeout: 5s          # Timeout de 5 segundos
      retries: 5           # 5 intentos antes de marcar como unhealthy
      start_period: 30s    # Espera 30 segundos antes de empezar healthchecks

  # (Opcional) Servicio de pgAdmin para administrar PostgreSQL
  # Interfaz web gráfica para gestionar bases de datos PostgreSQL
  pgadmin:
    image: dpage/pgadmin4:latest
    container_name: taskmanager-pgadmin
    restart: unless-stopped

    environment:
      # Credenciales de acceso a pgAdmin
      PGADMIN_DEFAULT_EMAIL: ${PGADMIN_EMAIL:-admin@admin.com}
      PGADMIN_DEFAULT_PASSWORD: ${PGADMIN_PASSWORD:-admin}

      # IMPORTANTE: En producción, usar credenciales seguras
      # y considerar autenticación con SSO

      # Configuración adicional
      PGADMIN_CONFIG_SERVER_MODE: 'False'  # Modo desktop (no requiere login múltiple)
      PGADMIN_CONFIG_MASTER_PASSWORD_REQUIRED: 'False'

    ports:
      # Interfaz web accesible en http://localhost:5050
      - "${PGADMIN_PORT:-5050}:80"

    volumes:
      # Persistencia de configuración de pgAdmin
      - pgadmin_data:/var/lib/pgadmin

    depends_on:
      postgres:
        condition: service_healthy  # Espera a que PostgreSQL esté healthy

    networks:
      - taskmanager-network

    # pgAdmin puede consumir recursos, limitarlos en desarrollo
    deploy:
      resources:
        limits:
          cpus: '0.5'
          memory: 512M

# Volúmenes para persistencia de datos
# Los datos persisten incluso después de 'docker compose down'
# Para eliminar datos: 'docker compose down -v'
volumes:
  postgres_data:
    driver: local
    # (Opcional) Especificar ubicación en el host
    # driver_opts:
    #   type: none
    #   o: bind
    #   device: ./postgres-data

  pgadmin_data:
    driver: local

# Red personalizada para aislamiento
# Bridge network permite comunicación entre contenedores
networks:
  taskmanager-network:
    driver: bridge
    # (Opcional) Configuración avanzada de red
    # ipam:
    #   config:
    #     - subnet: 172.28.0.0/16

# ============================================================================
# COMANDOS ÚTILES
# ============================================================================
#
# --- INICIAR Y DETENER ---
#
# Construir imágenes e iniciar todos los servicios:
#   docker compose up -d --build
#
# Iniciar servicios (sin rebuild):
#   docker compose up -d
#
# Iniciar solo servicios específicos:
#   docker compose up -d postgres    # Solo PostgreSQL
#   docker compose up -d app         # Solo la aplicación
#
# Detener servicios (mantiene datos):
#   docker compose stop
#
# Detener y eliminar contenedores (mantiene datos en volúmenes):
#   docker compose down
#
# Eliminar TODO incluyendo volúmenes (¡CUIDADO! Borra los datos):
#   docker compose down -v
#
# Reiniciar un servicio específico:
#   docker compose restart app
#   docker compose restart postgres
#
# --- LOGS Y MONITOREO ---
#
# Ver logs en tiempo real de todos los servicios:
#   docker compose logs -f
#
# Ver logs de servicios específicos:
#   docker compose logs -f app
#   docker compose logs -f postgres
#   docker compose logs -f pgadmin
#
# Ver últimas 100 líneas de logs:
#   docker compose logs --tail=100 app
#
# Ver estado de los servicios:
#   docker compose ps
#
# Ver uso de recursos:
#   docker stats
#   docker stats taskmanager-app
#   docker stats taskmanager-postgres
#
# Ver health status:
#   docker compose ps
#   docker inspect --format='{{.State.Health.Status}}' taskmanager-app
#
# --- EJECUTAR COMANDOS EN CONTENEDORES ---
#
# Abrir shell en la aplicación:
#   docker compose exec app sh
#
# Ejecutar comando SQL en PostgreSQL:
#   docker compose exec postgres psql -U postgres -d taskmanagement_db
#
# Ver variables de entorno de la aplicación:
#   docker compose exec app env
#
# Probar conectividad desde la app a PostgreSQL:
#   docker compose exec app ping postgres
#
# --- BASE DE DATOS ---
#
# Backup de la base de datos:
#   docker compose exec postgres pg_dump -U postgres taskmanagement_db > backup.sql
#
# Backup con timestamp:
#   docker compose exec postgres pg_dump -U postgres taskmanagement_db > backup-$(date +%Y%m%d-%H%M%S).sql
#
# Restaurar backup:
#   docker compose exec -T postgres psql -U postgres taskmanagement_db < backup.sql
#
# Conectarse a PostgreSQL:
#   docker compose exec postgres psql -U postgres -d taskmanagement_db
#
# --- REBUILD Y LIMPIEZA ---
#
# Rebuild completo (sin caché):
#   docker compose build --no-cache app
#
# Rebuild y reiniciar:
#   docker compose up -d --build --force-recreate app
#
# Limpiar imágenes huérfanas:
#   docker image prune
#
# Limpiar todo (contenedores, redes, volúmenes, imágenes):
#   docker system prune -a --volumes
#
# --- TESTING ---
#
# Verificar health de la aplicación:
#   curl http://localhost:8080/api/v1/actuator/health
#
# Verificar métricas de Actuator:
#   curl http://localhost:8080/api/v1/actuator/metrics
#
# Ver métricas de Prometheus:
#   curl http://localhost:8080/api/v1/actuator/prometheus
#
# Login con usuario de prueba:
#   curl -X POST http://localhost:8080/api/v1/auth/login \
#     -H "Content-Type: application/json" \
#     -d '{"username":"admin","password":"admin123"}'
#
# --- DESARROLLO ---
#
# Ver logs de build:
#   docker compose build app
#
# Reconstruir solo cuando cambien archivos:
#   docker compose up -d --build
#
# --- TROUBLESHOOTING ---
#
# Ver configuración final de docker-compose:
#   docker compose config
#
# Verificar red:
#   docker network inspect task-project_taskmanager-network
#
# Inspeccionar contenedor:
#   docker inspect taskmanager-app
#
# Ver procesos dentro del contenedor:
#   docker compose exec app ps aux
#
# Ver puertos expuestos:
#   docker compose port app 8080
#
# ============================================================================
# SEGURIDAD - IMPORTANTE PARA PRODUCCIÓN
# ============================================================================
#
# 1. Cambiar credenciales por defecto y usar contraseñas fuertes
# 2. No exponer puertos innecesarios (5432, 5050) públicamente
# 3. Usar Docker secrets en lugar de variables de entorno para passwords
# 4. Implementar SSL/TLS para todas las conexiones
# 5. Configurar pg_hba.conf para restringir accesos a PostgreSQL
# 6. Habilitar auditoría y logging adecuado
# 7. Mantener todas las imágenes actualizadas con parches de seguridad
# 8. Implementar backups automáticos y encriptados
# 9. Limitar recursos de contenedores apropiadamente
# 10. Usar imágenes oficiales y verificar checksums
# 11. Ejecutar contenedores con usuarios no privilegiados (ya implementado)
# 12. Usar networks privadas (no exponer servicios internos)
# 13. Implementar rate limiting y firewall
# 14. Escanear imágenes con herramientas como Trivy o Snyk
# 15. Usar .env file para variables sensibles (no commitear a git)
#
# ============================================================================
