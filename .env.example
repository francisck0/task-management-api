# ============================================================================
# VARIABLES DE ENTORNO - TASK MANAGEMENT API
# ============================================================================
#
# INSTRUCCIONES:
# 1. Copiar este archivo a .env: cp .env.example .env
# 2. Ajustar los valores según tu entorno
# 3. NUNCA commitear el archivo .env (ya está en .gitignore)
# 4. En producción, usar gestores de secretos (Vault, AWS Secrets Manager, etc.)
#
# IMPORTANTE:
# - En desarrollo local, puedes usar valores simples
# - En producción, usar contraseñas fuertes y cambiar todos los defaults
# - Rotar credenciales periódicamente
# - Limitar acceso al archivo .env (permisos 600)
# ============================================================================

# ============================================================================
# PERFIL DE SPRING BOOT
# ============================================================================
# Opciones: dev, test, prod
# dev: Recrea esquema, logs detallados, para desarrollo activo
# test: Para pruebas automatizadas
# prod: Validación de esquema, logs mínimos, optimizado para producción
SPRING_PROFILES_ACTIVE=dev

# ============================================================================
# CONFIGURACIÓN DE POSTGRESQL
# ============================================================================

# URL de conexión completa
# Formato: jdbc:postgresql://[host]:[puerto]/[nombre_bd]?[opciones]
DATABASE_URL=jdbc:postgresql://localhost:5432/taskmanagement_db

# Credenciales de la base de datos
# PRODUCCIÓN: Usar credenciales únicas y seguras, NO usar 'postgres'
DATABASE_USERNAME=postgres
DATABASE_PASSWORD=postgres

# Puerto de PostgreSQL (default: 5432)
# Cambiar si hay conflictos con otras instancias
POSTGRES_PORT=5432

# Nombre de la base de datos
POSTGRES_DB=taskmanagement_db

# Usuario de PostgreSQL
POSTGRES_USER=postgres

# Contraseña de PostgreSQL
# PRODUCCIÓN: Contraseña fuerte (mínimo 16 caracteres, caracteres especiales)
# Ejemplo: $(openssl rand -base64 32)
POSTGRES_PASSWORD=postgres

# ============================================================================
# CONFIGURACIÓN DE HIKARICP (POOL DE CONEXIONES)
# ============================================================================

# Tamaño máximo del pool de conexiones
# Recomendado: 10-20 para aplicaciones típicas
# Fórmula: ((core_count * 2) + effective_spindle_count)
# NO aumentar sin necesidad - más conexiones ≠ mejor performance
DB_POOL_SIZE=20

# Conexiones mínimas idle
# Recomendado: 50% de DB_POOL_SIZE o igual para carga estable
DB_POOL_MIN_IDLE=10

# ============================================================================
# CONFIGURACIÓN DEL SERVIDOR WEB
# ============================================================================

# Puerto del servidor Spring Boot
# En producción, típicamente 8080 detrás de un proxy inverso
SERVER_PORT=8080

# Número máximo de threads de Tomcat
# Ajustar según carga esperada y recursos disponibles
# Monitorear uso y ajustar incrementalmente
TOMCAT_THREADS_MAX=200

# ============================================================================
# CONFIGURACIÓN DE PGADMIN (OPCIONAL)
# ============================================================================

# Puerto de pgAdmin (interfaz web)
PGADMIN_PORT=5050

# Email de acceso a pgAdmin
# PRODUCCIÓN: Usar email real y seguro
PGADMIN_EMAIL=admin@admin.com

# Contraseña de pgAdmin
# PRODUCCIÓN: Contraseña fuerte y única
PGADMIN_PASSWORD=admin

# ============================================================================
# CONFIGURACIÓN DE LOGGING
# ============================================================================

# Ubicación del archivo de logs
# En producción, usar ubicación apropiada según SO
# Linux: /var/log/task-management-api/application.log
# Windows: C:/logs/task-management-api/application.log
LOG_FILE=logs/task-management-api.log

# Nivel de logging root
# Opciones: TRACE, DEBUG, INFO, WARN, ERROR
# Desarrollo: DEBUG
# Producción: INFO o WARN
LOGGING_LEVEL_ROOT=INFO

# Nivel de logging para la aplicación
LOGGING_LEVEL_APP=DEBUG

# ============================================================================
# CONFIGURACIÓN DE SEGURIDAD (PRODUCCIÓN)
# ============================================================================

# Habilitar SSL/TLS para conexión a PostgreSQL
# true: Requiere certificados configurados
# false: Conexión sin encriptar (solo desarrollo)
DB_SSL_ENABLED=false

# Modo SSL de PostgreSQL
# disable: Sin SSL
# allow: Intenta SSL, fallback a no-SSL
# prefer: Prefiere SSL, fallback a no-SSL
# require: Requiere SSL
# verify-ca: Requiere SSL y verifica CA
# verify-full: Requiere SSL y verifica hostname
DB_SSL_MODE=disable

# ============================================================================
# CONFIGURACIÓN DE APLICACIÓN PERSONALIZADA
# ============================================================================

# Nombre de la aplicación
APP_NAME=Task Management API

# Versión de la aplicación
APP_VERSION=1.0.0

# Entorno (development, staging, production)
APP_ENVIRONMENT=development

# ============================================================================
# CONFIGURACIÓN DE MONITOREO Y MÉTRICAS (OPCIONAL)
# ============================================================================

# Habilitar Spring Boot Actuator
# ACTUATOR_ENABLED=true

# Endpoints expuestos de Actuator
# ACTUATOR_ENDPOINTS=health,info,metrics,prometheus

# ============================================================================
# CONFIGURACIÓN DE CORS (PRODUCCIÓN)
# ============================================================================

# Orígenes permitidos para CORS
# Separar múltiples orígenes con comas
# DESARROLLO: localhost en varios puertos
# PRODUCCIÓN: Solo dominios específicos
CORS_ALLOWED_ORIGINS=http://localhost:3000,http://localhost:4200,http://localhost:5173

# ============================================================================
# CONFIGURACIÓN DE RATE LIMITING
# ============================================================================

# Habilitar/deshabilitar rate limiting
# true: Rate limiting activo (recomendado para producción)
# false: Sin límites (desarrollo/testing)
RATE_LIMIT_ENABLED=true

# Capacidad máxima del bucket (burst)
# Número máximo de tokens disponibles
# Permite ráfagas de hasta este número de peticiones
# Recomendado: 100-500 para API pública, 1000-5000 para API interna
RATE_LIMIT_CAPACITY=100

# Tokens que se rellenan por período
# Número de peticiones permitidas por período
# Debe ser igual o menor que RATE_LIMIT_CAPACITY
RATE_LIMIT_TOKENS=100

# Período de rellenado (en minutos)
# Cada cuánto tiempo se rellenan los tokens
# 1 = cada minuto (estándar)
# 5 = cada 5 minutos
# 60 = cada hora
RATE_LIMIT_PERIOD=1

# Rate limiting por IP (true) o global (false)
# true: Cada IP tiene su propio límite (recomendado)
# false: Todas las peticiones comparten el mismo límite
RATE_LIMIT_PER_IP=true

# ============================================================================
# CONFIGURACIÓN DE JWT (AUTENTICACIÓN)
# ============================================================================

# Secret key para firmar tokens JWT
# PRODUCCIÓN: Generar con: openssl rand -base64 64
# Mantener EXTREMADAMENTE seguro, rotar periódicamente
# NUNCA usar la clave de ejemplo en producción
# Ejemplo de generación: openssl rand -base64 64
JWT_SECRET=404E635266556A586E3272357538782F413F4428472B4B6250645367566B5970

# Duración del token en milisegundos
# 3600000 = 1 hora (recomendado para producción)
# 86400000 = 24 horas (desarrollo/testing)
# PRODUCCIÓN: Usar tiempos cortos (1-2 horas) con refresh tokens
JWT_EXPIRATION=86400000

# ============================================================================
# CONFIGURACIÓN DE CLOUD/DEPLOYMENT (PRODUCCIÓN)
# ============================================================================

# Para despliegue en Heroku, Railway, Render, etc.
# PORT=8080

# Para AWS RDS, Azure Database, GCP Cloud SQL
# DATABASE_URL=jdbc:postgresql://your-rds-endpoint:5432/dbname

# Para Kubernetes
# KUBERNETES_NAMESPACE=task-management-api
# KUBERNETES_SERVICE_NAME=task-api

# ============================================================================
# BACKUP Y MANTENIMIENTO
# ============================================================================

# Ubicación de backups
# BACKUP_DIR=/backups/task-management-api

# Retención de backups (días)
# BACKUP_RETENTION_DAYS=30

# ============================================================================
# EJEMPLOS DE CONFIGURACIONES ADICIONALES
# ============================================================================

# Máximo de tareas por usuario (lógica de negocio)
# MAX_TASKS_PER_USER=1000

# Días antes de archivar tareas completadas
# TASK_ARCHIVE_DAYS=90

# Habilitar modo mantenimiento
# MAINTENANCE_MODE=false

# ============================================================================
# NOTAS IMPORTANTES
# ============================================================================
#
# SEGURIDAD:
# 1. NUNCA commitear .env al repositorio
# 2. Usar contraseñas fuertes en producción (mínimo 16 caracteres)
# 3. Rotar credenciales periódicamente (cada 90 días)
# 4. Limitar permisos del archivo: chmod 600 .env
# 5. Usar gestores de secretos en producción (Vault, AWS Secrets Manager)
# 6. No compartir credenciales por email o chat
# 7. Habilitar SSL/TLS en producción
# 8. Usar autenticación de base de datos con certificados en producción
#
# PERFORMANCE:
# 1. Ajustar DB_POOL_SIZE según carga real (empezar bajo, incrementar según necesidad)
# 2. Monitorear uso de conexiones con JMX o Actuator
# 3. Ajustar TOMCAT_THREADS_MAX según recursos del servidor
# 4. No sobredimensionar - más recursos no siempre = mejor performance
#
# TROUBLESHOOTING:
# 1. Si hay errores de conexión: verificar DATABASE_URL y credenciales
# 2. Si hay timeouts: aumentar connection-timeout en application.yml
# 3. Si pool se agota: aumentar DB_POOL_SIZE incrementalmente
# 4. Si hay leaks: revisar que todos los services usen @Transactional
#
# ============================================================================

