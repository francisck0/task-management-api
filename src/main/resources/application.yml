# ============================================================================
# CONFIGURACIÓN PRINCIPAL - TASK MANAGEMENT API
# Spring Boot 3.5.7 + PostgreSQL 18 + Java 21
# ============================================================================
#
# Este archivo contiene la configuración completa de la aplicación con
# explicaciones detalladas sobre performance, seguridad y mejores prácticas.
#
# Perfiles disponibles:
# - default: Desarrollo local (este perfil)
# - dev: Desarrollo con recreación de esquema
# - test: Testing automatizado
# - prod: Producción (variables de entorno)

spring:
  application:
    name: task-management-api
    # Nombre de la aplicación usado en logs, métricas y monitoreo

  # ==========================================================================
  # CONFIGURACIÓN DE BASE DE DATOS - POSTGRESQL 18
  # ==========================================================================
  datasource:
    # URL de conexión JDBC
    # Formato: jdbc:postgresql://[host]:[puerto]/[nombre_bd]?[parámetros]
    # SEGURIDAD: Usar variable de entorno DATABASE_URL
    url: ${DATABASE_URL:jdbc:postgresql://localhost:5432/taskmanagement_db}

    # Credenciales de base de datos
    # SEGURIDAD: NUNCA hardcodear en producción - usar variables de entorno
    username: ${DATABASE_USERNAME:postgres}
    password: ${DATABASE_PASSWORD:postgres}
    driver-class-name: org.postgresql.Driver

    # -------------------------------------------------------------------------
    # HIKARICP - POOL DE CONEXIONES
    # -------------------------------------------------------------------------
    # HikariCP es el pool de conexiones por defecto en Spring Boot
    # Optimizado para alta performance y baja latencia
    hikari:
      maximum-pool-size: ${DB_POOL_SIZE:20}
      minimum-idle: ${DB_POOL_MIN_IDLE:10}
      connection-timeout: 20000

  # ==========================================================================
  # CONFIGURACIÓN DE INICIALIZACIÓN DE DATOS
  # ==========================================================================
  sql:
    init:
      # Ejecutar scripts SQL al inicio (schema.sql y data.sql)
      # IMPORTANTE: Con mode=always, Spring ejecuta los scripts en cada inicio
      # Orden de ejecución:
      # 1. Hibernate crea/actualiza tablas (ddl-auto: update)
      # 2. Spring ejecuta schema.sql (índices avanzados)
      # 3. Spring ejecuta data.sql (datos iniciales)
      mode: always

      # Continuar si hay errores (para evitar duplicados en data.sql)
      # y para ignorar errores si los índices ya existen en schema.sql
      continue-on-error: true

      # Orden de ejecución de scripts
      # schema-locations: Se ejecuta primero (DDL - estructura)
      # data-locations: Se ejecuta segundo (DML - datos)
      # Por defecto busca: schema.sql y data.sql en resources/

      # Modo de ejecución
      # embedded: Solo en BD embebidas (H2, HSQLDB)
      # always: Siempre (desarrollo y producción)
      # never: Nunca

      # Platform específica (opcional)
      # Si quieres scripts específicos por BD:
      # schema-locations: classpath:schema-postgresql.sql
      # platform: postgresql

  # ==========================================================================
  # CONFIGURACIÓN DE JPA / HIBERNATE
  # ==========================================================================
  jpa:
    # -------------------------------------------------------------------------
    # GESTIÓN DEL ESQUEMA DE BASE DE DATOS
    # -------------------------------------------------------------------------
    hibernate:
      # DDL (Data Definition Language) - Cómo gestionar el esquema
      #
      # OPCIONES:
      # - none: No hace nada (usar con migrations como Flyway/Liquibase)
      # - validate: Solo valida que el esquema coincide con las entidades
      # - update: Actualiza el esquema (CUIDADO: no elimina columnas)
      # - create: Crea el esquema desde cero (BORRA DATOS)
      # - create-drop: Crea al iniciar, elimina al cerrar (solo testing)
      #
      # RECOMENDACIONES:
      # - Desarrollo: update (para iterar rápido)
      # - Testing: create-drop (esquema limpio cada vez)
      # - Producción: validate o none (usar migrations)
      ddl-auto: update

      # PERFORMANCE: Estrategia de nomenclatura de tablas/columnas
      # PhysicalNamingStrategy: convierte camelCase a snake_case
      # Por ejemplo: userName -> user_name
      naming:
        physical-strategy: org.hibernate.boot.model.naming.CamelCaseToUnderscoresNamingStrategy
        implicit-strategy: org.springframework.boot.orm.jpa.hibernate.SpringImplicitNamingStrategy

    # -------------------------------------------------------------------------
    # LOGGING Y DEBUGGING
    # -------------------------------------------------------------------------
    # DESARROLLO: Mostrar queries SQL en logs
    # PRODUCCIÓN: Desactivar (usar logging level WARN)
    show-sql: true

    # DESARROLLO: Muestra los valores de los parámetros
    # Útil para debugging pero impacta performance
    properties:
      # FORMATO DE QUERIES
      hibernate:
        # Formatea SQL para legibilidad
        format_sql: true

        # Agrega comentarios a las queries con información contextual
        use_sql_comments: true

        # DIALECTO DE BASE DE DATOS
        # Dialecto específico para PostgreSQL
        # Optimiza queries para PostgreSQL específicamente
        dialect: org.hibernate.dialect.PostgreSQLDialect

        # PERFORMANCE: Batch processing
        # Agrupa múltiples inserts/updates en una sola operación
        # Mejora significativamente el rendimiento en operaciones masivas
        jdbc:
          batch_size: 20
          # Ordena los inserts/updates para mejor batching
          order_inserts: true
          order_updates: true
          # Agrupa por lotes los inserts
          batch_versioned_data: true

        # PERFORMANCE: Query plan cache
        # Cachea planes de ejecución de queries
        query:
          plan_cache_max_size: 2048
          plan_parameter_metadata_max_size: 128

        # PERFORMANCE: Segunda caché (L2 Cache)
        # Caché de entidades a nivel de SessionFactory
        # Mejora performance en lecturas frecuentes
        # Requiere configuración adicional por entidad
        # cache:
        #   use_second_level_cache: true
        #   use_query_cache: true
        #   region:
        #     factory_class: org.hibernate.cache.jcache.JCacheRegionFactory

        # SEGURIDAD: Validación de esquema
        # Valida el esquema al inicio
        # check_nullability: true

        # PERFORMANCE: Fetch estrategia
        # Controla cómo Hibernate carga relaciones
        # max_fetch_depth: 3
        # default_batch_fetch_size: 16

        # MONITOREO: Estadísticas de Hibernate
        # Habilita recolección de estadísticas (impacto mínimo en performance)
        generate_statistics: true

        # LOGGING: Slow query logging
        # Registra queries lentas (tiempo en ms)
        # session:
        #   events:
        #     log:
        #       LOG_QUERIES_SLOWER_THAN_MS: 1000

    # -------------------------------------------------------------------------
    # PROPIEDADES JDBC AVANZADAS
    # -------------------------------------------------------------------------
    # Configuración adicional del driver PostgreSQL JDBC
    # properties:
    #   javax:
    #     persistence:
    #       query:
    #         timeout: 10000  # Timeout de queries en ms

  # ==========================================================================
  # CONFIGURACIÓN DE REDIS CACHE
  # ==========================================================================
  # Redis es un almacén de datos en memoria usado como caché distribuido
  # VENTAJAS:
  # - Latencia ultra-baja (microsegundos vs milisegundos de PostgreSQL)
  # - Reduce carga en la base de datos principal
  # - Compartir caché entre múltiples instancias de la aplicación
  # - Escalabilidad horizontal
  #
  # CASOS DE USO:
  # - Caché de tareas consultadas frecuentemente (GET /tasks/{id})
  # - Caché de listas de tareas por usuario
  # - Sesiones de usuario (alternativa a sesiones en BD)
  # - Rate limiting distribuido
  #
  data:
    redis:
      # Hostname de Redis
      # DESARROLLO: localhost
      # PRODUCCIÓN: Variable de entorno REDIS_HOST
      # Docker: Nombre del servicio (redis)
      host: ${REDIS_HOST:localhost}

      # Puerto de Redis
      # Default: 6379
      port: ${REDIS_PORT:6379}

      # Índice de base de datos Redis (0-15)
      # Redis soporta múltiples DBs en una instancia
      # 0 = Default, usar diferentes índices para diferentes propósitos
      database: ${REDIS_DB:0}

      # Password para autenticación (si está configurado en Redis)
      # SEGURIDAD: Siempre usar password en producción
      # password: ${REDIS_PASSWORD:}

      # Timeout de conexión en milisegundos
      # Tiempo máximo para establecer conexión
      timeout: 2000ms

      # -----------------------------------------------------------------------
      # LETTUCE CLIENT CONFIGURATION
      # -----------------------------------------------------------------------
      # Lettuce es el cliente Redis por defecto en Spring Boot
      # Soporta operaciones asíncronas y reactivas
      lettuce:
        # Pool de conexiones
        pool:
          # PERFORMANCE: Número máximo de conexiones
          # Valor típico: 8-20 para aplicaciones normales
          # Redis es muy rápido, no necesita tantas conexiones como PostgreSQL
          max-active: ${REDIS_POOL_MAX:20}

          # PERFORMANCE: Conexiones idle máximas
          # Conexiones que permanecen en el pool sin usarse
          max-idle: ${REDIS_POOL_MAX_IDLE:10}

          # PERFORMANCE: Conexiones idle mínimas
          # Mantener conexiones listas para uso inmediato
          min-idle: ${REDIS_POOL_MIN_IDLE:5}

          # PERFORMANCE: Tiempo máximo de espera para obtener una conexión (ms)
          # Si el pool está lleno, esperar este tiempo antes de fallar
          # -1 = esperar indefinidamente (no recomendado)
          max-wait: 2000ms

          # SEGURIDAD: Habilitar test on borrow
          # Valida que la conexión funciona antes de usarla
          # time-between-eviction-runs: 60000ms

        # Shutdown timeout
        # Tiempo de espera al cerrar el pool de conexiones
        shutdown-timeout: 100ms

  # ==========================================================================
  # CONFIGURACIÓN DE SPRING CACHE
  # ==========================================================================
  # Spring Cache es la abstracción de caché de Spring
  # Permite usar diferentes implementaciones (Redis, Caffeine, Hazelcast, etc)
  # con las mismas anotaciones (@Cacheable, @CacheEvict, @CachePut)
  #
  cache:
    # Tipo de caché
    # redis: Usar Redis como backend de caché
    # caffeine: Caché local en memoria (alternativa sin Redis)
    # none: Deshabilitar caché
    type: redis

    # Configuración específica de Redis Cache
    redis:
      # TTL (Time To Live) por defecto para entradas de caché
      # Después de este tiempo, las entradas expiran automáticamente
      # RECOMENDACIONES:
      # - Datos que cambian poco: 1 hora - 24 horas
      # - Datos que cambian frecuentemente: 5-30 minutos
      # - Datos críticos: 1-5 minutos
      #
      # null = Sin expiración (no recomendado)
      # Formato: ISO-8601 duration (PT15M = 15 minutos, PT1H = 1 hora)
      time-to-live: ${CACHE_TTL:PT30M}  # 30 minutos por defecto

      # Permitir valores null en caché
      # true: Cachear valores null (previene cache penetration attacks)
      # false: No cachear null (puede causar queries repetidas si el valor no existe)
      # RECOMENDADO: true para seguridad
      cache-null-values: true

      # Prefijo para todas las claves en Redis
      # Ayuda a organizar y evitar colisiones
      # Ejemplo: task-api:tasks:123
      key-prefix: "task-api::"

      # Usar el prefijo en las claves
      use-key-prefix: true

      # SEGURIDAD: Deshabilitar caché de colecciones vacías
      # Previene DoS mediante queries que retornan vacío
      # enable-statistics: true  # Habilitar estadísticas de caché (útil para monitoreo)

# ==========================================================================
# CONFIGURACIÓN DEL SERVIDOR WEB
# ==========================================================================
server:
  # Puerto del servidor embebido Tomcat
  port: ${SERVER_PORT:8080}

  # Context path de la aplicación (sin versión)
  # La versión se maneja a nivel de controlador usando ApiVersion.V1
  # Ejemplo: http://localhost:8080/api/v1/tasks
  #          └─────context─────┘└v1┘└tasks┘
  servlet:
    context-path: /api

    # SEGURIDAD: Headers de respuesta HTTP
    # session:
    #   cookie:
    #     http-only: true  # Previene XSS
    #     secure: true     # Solo HTTPS (habilitar en producción)
    #     same-site: strict  # Protección CSRF

  # PERFORMANCE: Configuración de Tomcat
  tomcat:
    # Número de threads para manejar requests
    threads:
      max: ${TOMCAT_THREADS_MAX:200}        # Máximo de threads
      min-spare: ${TOMCAT_THREADS_MIN:10}   # Threads mínimos en espera

    # Tamaño máximo de request body
    max-http-form-post-size: 10MB

    # Timeout de conexión
    connection-timeout: 20s

    # PERFORMANCE: Compresión de respuestas
    compression:
      enabled: true
      mime-types: text/html,text/xml,text/plain,text/css,text/javascript,application/javascript,application/json
      min-response-size: 1024

  # SEGURIDAD: Manejo de errores
  error:
    # No incluir stacktrace en respuestas de error en producción
    include-stacktrace: on_param  # never en producción
    include-message: always
    include-binding-errors: always

# ============================================================================
# CONFIGURACIÓN DE LOGGING
# ============================================================================
logging:
  # Patrón de formato de logs
  # %X{correlationId} extrae el correlation ID del MDC (Mapped Diagnostic Context)
  # El correlation ID permite rastrear requests completos a través de todos los logs
  pattern:
    console: "%d{yyyy-MM-dd HH:mm:ss} [%X{correlationId}] - %msg%n"
    # file: "%d{yyyy-MM-dd HH:mm:ss} [%X{correlationId}] [%thread] %-5level %logger{36} - %msg%n"

  # Niveles de log por paquete
  # TRACE < DEBUG < INFO < WARN < ERROR
  level:
    # Nivel root (por defecto para todo)
    # PRODUCCIÓN: WARN, DESARROLLO: INFO o DEBUG
    root: ${LOGGING_LEVEL_ROOT:INFO}

    # Nuestra aplicación
    # PRODUCCIÓN: INFO, DESARROLLO: DEBUG
    com.taskmanagement.api: ${LOGGING_LEVEL_APP:DEBUG}

    # Spring Framework
    org.springframework.web: INFO
    org.springframework.security: DEBUG
    org.springframework.boot: INFO

    # Hibernate y JPA
    org.hibernate.SQL: DEBUG                    # Muestra queries SQL
    org.hibernate.type.descriptor.sql: TRACE    # Muestra parámetros de queries
    org.hibernate.stat: DEBUG                   # Estadísticas de Hibernate
    org.hibernate.engine.transaction: DEBUG     # Transacciones

    # HikariCP
    com.zaxxer.hikari: INFO                     # Pool de conexiones
    com.zaxxer.hikari.HikariConfig: DEBUG       # Configuración del pool

    # PostgreSQL Driver
    org.postgresql: INFO

  # (Opcional) Guardar logs en archivo
  # file:
  #   name: logs/task-management-api.log
  #   max-size: 10MB
  #   max-history: 30
  #   total-size-cap: 1GB

# ============================================================================
# CONFIGURACIÓN DE ACTUATOR (MONITOREO Y MÉTRICAS)
# ============================================================================
# Spring Boot Actuator proporciona endpoints de producción para:
# - Monitoreo de salud de la aplicación
# - Métricas de rendimiento
# - Información de la aplicación
# - Estado de componentes (BD, disco, etc)
#
# SEGURIDAD: Actuator expone información sensible
# - En desarrollo: Endpoints abiertos para facilitar debugging
# - En producción: Endpoints protegidos y limitados
#
management:
  # Configuración de endpoints
  endpoints:
    web:
      # Exponer endpoints específicos
      # health: Estado de salud de la aplicación
      # info: Información de la aplicación
      # metrics: Métricas de la aplicación
      # prometheus: Métricas en formato Prometheus
      exposure:
        include: health,info,metrics,prometheus

      # Ruta base para acceder a los endpoints
      # URL: http://localhost:8080/api/v1/actuator/health
      base-path: /actuator

  # Configuración del endpoint de health
  endpoint:
    health:
      # Mostrar detalles completos de salud
      # never: Nunca mostrar detalles
      # when-authorized: Solo para usuarios autenticados
      # always: Siempre mostrar (solo desarrollo)
      show-details: when-authorized

      # Incluir componentes específicos en health check
      show-components: when-authorized

  # Configuración de health indicators
  health:
    # Verificar conectividad a la base de datos
    db:
      enabled: true

    # Verificar espacio en disco
    diskspace:
      enabled: true
      threshold: 10MB # Alerta si queda menos de 10MB

  # Configuración de métricas
  metrics:
    # Tags globales para todas las métricas
    tags:
      application: ${spring.application.name}
      environment: ${spring.profiles.active:default}

    # Exportar métricas en formato Prometheus
    export:
      prometheus:
        enabled: true

  # Información de la aplicación (expuesta en /actuator/info)
  info:
    # Incluir información de Git (si existe git.properties)
    git:
      mode: full

    # Incluir información de build
    build:
      enabled: true

    # Incluir información del entorno Java
    java:
      enabled: true

    # Incluir información del sistema operativo
    os:
      enabled: true

# ============================================================================
# CONFIGURACIÓN PERSONALIZADA DE LA APLICACIÓN
# ============================================================================
# Puedes agregar propiedades custom aquí
app:
  name: Task Management API
  version: 1.0.0
  description: API REST para gestión de tareas

  # Configuraciones de negocio
  # max-tasks-per-user: 100
  # task-expiration-days: 30

# ============================================================================
# CONFIGURACIÓN DE CORS (Cross-Origin Resource Sharing)
# ============================================================================
# CORS permite que aplicaciones web desde otros dominios accedan a la API
# Necesario cuando frontend y backend están en diferentes puertos/dominios
cors:
  # Orígenes permitidos para hacer peticiones a la API
  # DESARROLLO: localhost con diferentes puertos (React, Angular, Vue)
  # PRODUCCIÓN: Solo dominios de producción
  allowed-origins: ${CORS_ALLOWED_ORIGINS:http://localhost:3000,http://localhost:4200,http://localhost:5173}

# ============================================================================
# CONFIGURACIÓN DE JWT (JSON WEB TOKEN)
# ============================================================================
jwt:
  # Clave secreta para firmar los tokens JWT
  # ⚠️ SEGURIDAD CRÍTICA: DEBES configurar esta variable de entorno
  #
  # La aplicación NO arrancará sin un JWT secret configurado.
  # NO uses el valor por defecto en producción.
  #
  # CÓMO CONFIGURAR:
  # 1. Generar secret seguro:
  #    $ openssl rand -base64 64
  #    $ ./scripts/generate-secrets.sh
  #
  # 2. Configurar variable de entorno JWT_SECRET:
  #    Linux/Mac:       export JWT_SECRET="tu-secret-aqui"
  #    Windows:         $env:JWT_SECRET="tu-secret-aqui"
  #    Docker Compose:  environment: JWT_SECRET=tu-secret-aqui
  #    Kubernetes:      kubectl create secret generic jwt-secret --from-literal=JWT_SECRET=...
  #
  # DESARROLLO LOCAL:
  # Para desarrollo, se acepta el valor por defecto (la aplicación lo detectará y advertirá).
  # En PRODUCCIÓN, la aplicación FALLARÁ si usas el valor por defecto.
  #
  # Valor por defecto SOLO para desarrollo (NO USAR EN PRODUCCIÓN):
  secret-key: ${JWT_SECRET:404E635266556A586E3272357538782F413F4428472B4B6250645367566B5970}

  # ============================================================================
  # ACCESS TOKEN (JWT de corta duración para acceder a recursos)
  # ============================================================================
  # Tiempo de expiración del access token en milisegundos
  # RECOMENDACIONES:
  # - Desarrollo: 24 horas (86400000ms) para comodidad
  # - Producción: 15 minutos (900000ms) - 1 hora (3600000ms) por seguridad
  #
  # Si un access token es robado, solo es válido por este tiempo.
  # Tiempos cortos + Refresh Tokens = Mejor seguridad
  expiration: ${JWT_EXPIRATION:3600000}  # 1 hora (cambiado de 24h)

  # ============================================================================
  # REFRESH TOKEN (Token de larga duración para renovar access tokens)
  # ============================================================================
  refresh-token:
    # Duración del refresh token en días
    # RECOMENDACIONES:
    # - Desarrollo: 7-30 días
    # - Producción: 7-14 días
    # - Aplicaciones móviles: 30-90 días
    #
    # Después de este tiempo, el usuario debe hacer login de nuevo
    expiration-days: ${JWT_REFRESH_EXPIRATION_DAYS:7}

    # Habilitar rotación automática de refresh tokens
    # true: Cada uso genera un nuevo token (más seguro)
    # false: El mismo token se puede usar múltiples veces
    #
    # SEGURIDAD: Rotation detecta tokens comprometidos
    # Si un atacante roba un token y lo usa, el siguiente uso (del usuario
    # legítimo o del atacante) generará una alerta y revocará todos los tokens
    rotation-enabled: ${JWT_REFRESH_ROTATION:true}

    # Límite de dispositivos/sesiones simultáneas por usuario
    # Valores típicos:
    # - 1: Solo un dispositivo (máxima seguridad)
    # - 3-5: Múltiples dispositivos (normal)
    # - 10+: Sin límite práctico
    #
    # Si un usuario supera este límite, se eliminan las sesiones más antiguas
    max-devices: ${JWT_REFRESH_MAX_DEVICES:5}

# ============================================================================
# CONFIGURACIÓN DE RATE LIMITING
# ============================================================================
# Rate Limiting protege la API contra abuso y ataques DDoS
# Limita el número de peticiones que un cliente puede hacer en un período de tiempo
#
# ALGORITMO: Token Bucket
# - Cada cliente tiene un "bucket" (cubo) con tokens
# - Cada petición consume 1 token
# - Los tokens se rellenan a una tasa constante
# - Si no hay tokens disponibles, la petición es rechazada con 429 Too Many Requests
#
# CONFIGURACIÓN:
rate-limit:
  # Habilitar/deshabilitar rate limiting globalmente
  # true: Rate limiting activo
  # false: Rate limiting desactivado (permitir todas las peticiones)
  # PRODUCCIÓN: true
  # DESARROLLO: false o true con límites generosos
  enabled: ${RATE_LIMIT_ENABLED:true}

  # Capacidad del bucket (número máximo de tokens)
  # Representa el "burst" máximo de peticiones permitido
  # Ejemplo: 100 permite hasta 100 peticiones en ráfaga
  # RECOMENDADO:
  # - API pública: 100-500
  # - API interna: 1000-5000
  # - Usuarios premium: 10000+
  capacity: ${RATE_LIMIT_CAPACITY:100}

  # Número de tokens que se rellenan por intervalo
  # Define cuántas peticiones se permiten por período
  # Ejemplo: 100 tokens con period=1 minuto = 100 peticiones/minuto
  # RECOMENDADO:
  # - API ligera: 100-500 req/min
  # - API moderada: 500-1000 req/min
  # - API pesada: 1000-5000 req/min
  tokens: ${RATE_LIMIT_TOKENS:100}

  # Período de rellenado en minutos
  # Cada cuánto tiempo se rellenan los tokens
  # Ejemplo: 1 = cada minuto, 5 = cada 5 minutos
  # RECOMENDADO: 1 minuto (estándar de la industria)
  period: ${RATE_LIMIT_PERIOD:1}

  # Rate limiting por IP (true) o global (false)
  # true: Cada IP tiene su propio límite (recomendado)
  # false: Todas las peticiones comparten el mismo límite
  # RECOMENDADO: true (por IP)
  per-ip: ${RATE_LIMIT_PER_IP:true}

  # Paths excluidos del rate limiting
  # Útil para endpoints públicos, documentación, health checks
  # Soporta patrones Ant-style (**, *, ?)
  excluded-paths:
    - /actuator/**           # Health checks y métricas
    - /swagger-ui/**         # Documentación Swagger
    - /v3/api-docs/**        # OpenAPI docs
    - /favicon.ico           # Favicon
    # Agregar más según necesidad:
    # - /auth/login          # Login (considerar rate limiting separado)
    # - /public/**           # Recursos públicos

# EJEMPLOS DE CONFIGURACIÓN SEGÚN CASO DE USO:
#
# 1. API PÚBLICA GRATUITA (restrictiva):
#    capacity: 50
#    tokens: 50
#    period: 1
#    Resultado: 50 peticiones/minuto
#
# 2. API CON AUTENTICACIÓN (moderada):
#    capacity: 200
#    tokens: 200
#    period: 1
#    Resultado: 200 peticiones/minuto
#
# 3. API INTERNA (generosa):
#    capacity: 1000
#    tokens: 1000
#    period: 1
#    Resultado: 1000 peticiones/minuto
#
# 4. RATE LIMITING POR HORA:
#    capacity: 5000
#    tokens: 5000
#    period: 60
#    Resultado: 5000 peticiones/hora

---
# ============================================================================
# PERFIL: DESARROLLO (DEV)
# ============================================================================
# Activar: --spring.profiles.active=dev
# Recrea el esquema en cada inicio (útil para desarrollo activo)

spring:
  config:
    activate:
      on-profile: dev

  datasource:
    url: jdbc:postgresql://localhost:5432/taskmanagement_db_dev
    hikari:
      maximum-pool-size: 5  # Menos conexiones en desarrollo
      leak-detection-threshold: 30000  # Detección agresiva de leaks

  jpa:
    hibernate:
      ddl-auto: create-drop  # Recrea esquema en cada inicio
    show-sql: true
    properties:
      hibernate:
        format_sql: true
        generate_statistics: true

logging:
  level:
    com.taskmanagement.api: DEBUG
    org.hibernate.SQL: DEBUG
    org.hibernate.type.descriptor.sql: TRACE

---
# ============================================================================
# PERFIL: TESTING (TEST)
# ============================================================================
# Activar: --spring.profiles.active=test
# Optimizado para pruebas automatizadas

spring:
  config:
    activate:
      on-profile: test

  datasource:
    # Usar H2 en memoria para tests (más rápido)
    # O PostgreSQL en contenedor de test
    url: jdbc:postgresql://localhost:5432/taskmanagement_db_test
    hikari:
      maximum-pool-size: 5
      connection-timeout: 5000

  jpa:
    hibernate:
      ddl-auto: create-drop  # Esquema limpio para cada test
    show-sql: false          # No contaminar logs de tests
    properties:
      hibernate:
        format_sql: false
        generate_statistics: false

logging:
  level:
    root: WARN
    com.taskmanagement.api: INFO
    org.hibernate.SQL: WARN

---
# ============================================================================
# PERFIL: PRODUCCIÓN (PROD)
# ============================================================================
# Activar: --spring.profiles.active=prod
# TODAS las credenciales y configuraciones sensibles vienen de variables de entorno

spring:
  config:
    activate:
      on-profile: prod

  datasource:
    # SEGURIDAD: Obtener configuración de variables de entorno
    url: ${DATABASE_URL}
    username: ${DATABASE_USERNAME}
    password: ${DATABASE_PASSWORD}

    hikari:
      # PERFORMANCE: Configuración optimizada para producción
      maximum-pool-size: ${DB_POOL_SIZE:20}
      minimum-idle: ${DB_POOL_MIN_IDLE:10}
      connection-timeout: 30000
      idle-timeout: 600000
      max-lifetime: 1800000
      leak-detection-threshold: 0  # Desactivar en producción (overhead)

      # SEGURIDAD: SSL para conexión a PostgreSQL
      # data-source-properties:
      #   ssl: true
      #   sslmode: require

  jpa:
    hibernate:
      # SEGURIDAD: Solo validar, NUNCA modificar esquema en producción
      ddl-auto: validate
    show-sql: false  # No loguear queries en producción
    properties:
      hibernate:
        format_sql: false
        generate_statistics: false  # Mínimo overhead en producción

  # SEGURIDAD: Configuración segura del servidor
  server:
    port: ${PORT:8080}
    error:
      include-stacktrace: never    # Nunca exponer stacktraces
      include-message: always
    tomcat:
      threads:
        max: ${TOMCAT_THREADS_MAX:200}
      connection-timeout: 20s

# LOGGING: Nivel apropiado para producción
logging:
  level:
    root: WARN
    com.taskmanagement.api: INFO
    org.hibernate.SQL: WARN
    org.springframework: WARN

  # Guardar logs en archivo en producción
  file:
    name: ${LOG_FILE:/var/log/task-management-api/application.log}
    max-size: 100MB
    max-history: 30

# ============================================================================
# NOTAS IMPORTANTES DE SEGURIDAD Y PERFORMANCE
# ============================================================================
#
# SEGURIDAD:
# 1. Nunca commitear credenciales en código fuente
# 2. Usar variables de entorno o gestores de secretos (Vault, AWS Secrets Manager)
# 3. Habilitar SSL/TLS para conexiones a PostgreSQL en producción
# 4. Configurar pg_hba.conf apropiadamente
# 5. Usar usuarios de BD con privilegios mínimos necesarios
# 6. Implementar rate limiting y protección DDoS
# 7. Mantener dependencias actualizadas
# 8. Habilitar CORS solo para orígenes conocidos
# 9. Implementar autenticación y autorización (Spring Security)
# 10. Auditar y monitorear accesos a la BD
#
# PERFORMANCE:
# 1. Ajustar pool de conexiones según carga real (no más de 20-30)
# 2. Usar índices apropiados en PostgreSQL
# 3. Habilitar prepared statement cache
# 4. Usar batch processing para operaciones masivas
# 5. Implementar paginación en endpoints que retornan listas
# 6. Usar proyecciones o DTOs en lugar de entidades completas
# 7. Implementar caché (Redis, Caffeine) para datos frecuentes
# 8. Monitorear slow queries y optimizarlas
# 9. Usar connection pooling apropiadamente
# 10. Considerar read replicas para alta lectura
#
# ============================================================================
